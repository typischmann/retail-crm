

DROP TRIGGER IF EXISTS INVENTORY_CHANGE_RECORD_BEFORE_IT ON INVENTORY_CHANGE_RECORDS;
DROP TRIGGER IF EXISTS INVENTORY_CHANGE_RECORD_BEFORE_UT ON INVENTORY_CHANGE_RECORDS;
DROP TRIGGER IF EXISTS INVENTORY_CURRENT_ITEM_BEFORE_IT ON INVENTORY_CURRENT_ITEMS;
DROP TRIGGER IF EXISTS INVENTORY_CURRENT_ITEM_BEFORE_UT ON INVENTORY_CURRENT_ITEMS;
DROP TRIGGER IF EXISTS ORDERS_BEFORE_UT ON ORDERS;
DROP TRIGGER IF EXISTS ORDER_ITEM_BEFORE_UT ON ORDER_ITEMS;
DROP TRIGGER IF EXISTS SYS_USER_BEFORE_IT ON SYS_USERS;
DROP TRIGGER IF EXISTS SYS_USER_BEFORE_UT ON SYS_USERS;


CREATE OR REPLACE FUNCTION ORDERS_BEFORE_UT_FUNC() RETURNS TRIGGER
AS $ORDERS_BEFORE_UT$
BEGIN
	NEW.DELTA_TS := current_timestamp;
	RETURN NEW;
END;
$ORDERS_BEFORE_UT$ LANGUAGE plpgsql;


CREATE TRIGGER ORDERS_BEFORE_UT BEFORE UPDATE ON ORDERS
FOR EACH ROW
EXECUTE PROCEDURE ORDERS_BEFORE_UT_FUNC();

/**
 * 
 */
CREATE OR REPLACE FUNCTION  ORDER_ITEM_BEFORE_UT_FUNC() RETURNS TRIGGER
AS $ORDER_ITEM_BEFORE_UT$
BEGIN
	NEW.DELTA_TS := current_timestamp;
	RETURN NEW;
END;
$ORDER_ITEM_BEFORE_UT$ LANGUAGE plpgsql;

CREATE TRIGGER ORDER_ITEM_BEFORE_UT BEFORE UPDATE ON ORDER_ITEMS
FOR EACH ROW
EXECUTE PROCEDURE ORDER_ITEM_BEFORE_UT_FUNC();

/**
 * 
 */
CREATE OR REPLACE FUNCTION INVENTORY_CHANGE_RECORD_BEFORE_IT_FUNC() RETURNS TRIGGER
AS $INVENTORY_CHANGE_RECORD_BEFORE_IT$
BEGIN
	--TODO Check the feasibility for inventory
	NEW.DELTA_TS := current_timestamp;
	RETURN NEW;
END ;
$INVENTORY_CHANGE_RECORD_BEFORE_IT$ LANGUAGE plpgsql;

CREATE TRIGGER INVENTORY_CHANGE_RECORD_BEFORE_IT BEFORE INSERT ON INVENTORY_CHANGE_RECORDS
FOR EACH ROW
EXECUTE PROCEDURE INVENTORY_CHANGE_RECORD_BEFORE_IT_FUNC();

CREATE OR REPLACE FUNCTION INVENTORY_CHANGE_RECORD_BEFORE_UT_FUNC() RETURNS TRIGGER
AS $INVENTORY_CHANGE_RECORD_BEFORE_UT$
BEGIN
	--TODO Check the feasibility for inventory
	NEW.DELTA_TS := current_timestamp;
	RETURN NEW;
END ;
$INVENTORY_CHANGE_RECORD_BEFORE_UT$ LANGUAGE plpgsql;

CREATE TRIGGER INVENTORY_CHANGE_RECORD_BEFORE_UT BEFORE UPDATE ON INVENTORY_CHANGE_RECORDS
FOR EACH ROW
EXECUTE PROCEDURE INVENTORY_CHANGE_RECORD_BEFORE_UT_FUNC();

/**
 * 
 */
CREATE OR REPLACE FUNCTION INVENTORY_CURRENT_ITEM_BEFORE_IT_FUNC() RETURNS TRIGGER
AS $INVENTORY_CURRENT_ITEM_BEFORE_IT$
BEGIN
	--TODO Check the feasibility for inventory
	NEW.DELTA_TS := current_timestamp;
	RETURN NEW;
END ;
$INVENTORY_CURRENT_ITEM_BEFORE_IT$ LANGUAGE plpgsql;

CREATE TRIGGER INVENTORY_CURRENT_ITEM_BEFORE_IT BEFORE INSERT ON INVENTORY_CURRENT_ITEMS
FOR EACH ROW
EXECUTE PROCEDURE INVENTORY_CURRENT_ITEM_BEFORE_IT_FUNC();

CREATE OR REPLACE FUNCTION INVENTORY_CURRENT_ITEM_BEFORE_UT_FUNC() RETURNS TRIGGER
AS $INVENTORY_CURRENT_ITEM_BEFORE_UT$
BEGIN
	--TODO Check the feasibility for inventory
	NEW.DELTA_TS := current_timestamp;
	RETURN NEW;
END ;
$INVENTORY_CURRENT_ITEM_BEFORE_UT$ LANGUAGE plpgsql;

CREATE TRIGGER INVENTORY_CURRENT_ITEM_BEFORE_UT BEFORE UPDATE ON INVENTORY_CURRENT_ITEMS
FOR EACH ROW
EXECUTE PROCEDURE INVENTORY_CURRENT_ITEM_BEFORE_UT_FUNC();

/**
 * 
 */
CREATE OR REPLACE FUNCTION SYS_USER_BEFORE_IT_FUNC() RETURNS TRIGGER
AS $SYS_USER_BEFORE_IT$
BEGIN
	IF NEW.USER_PASSWORD IS NOT NULL THEN
		NEW.USER_PASSWORD := crypt(NEW.USER_PASSWORD, gen_salt('md5'));
	END IF;
	RETURN NEW;
END; 
$SYS_USER_BEFORE_IT$ LANGUAGE plpgsql;

CREATE TRIGGER SYS_USER_BEFORE_IT BEFORE INSERT ON SYS_USERS
FOR EACH ROW
EXECUTE PROCEDURE  SYS_USER_BEFORE_IT_FUNC();

CREATE OR REPLACE FUNCTION SYS_USER_BEFORE_UT_FUNC() RETURNS TRIGGER
AS $SYS_USER_BEFORE_UT$
BEGIN
	IF NEW.USER_PASSWORD IS NOT NULL THEN
		NEW.USER_PASSWORD := crypt(NEW.USER_PASSWORD, gen_salt('md5'));
	END IF;
	RETURN NEW;
END; 
$SYS_USER_BEFORE_UT$ LANGUAGE plpgsql;

CREATE TRIGGER SYS_USER_BEFORE_UT BEFORE UPDATE ON SYS_USERS
FOR EACH ROW
EXECUTE PROCEDURE  SYS_USER_BEFORE_UT_FUNC();

---------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION AUTHENTICATE_SYS_USER_FUNC(sys_user_name VARCHAR(64), sys_user_password VARCHAR(64))
RETURNS BOOLEAN AS $AUTHENTICATE_SYS_USER$
BEGIN
	RETURN (SELECT USER_PASSWORD = crypt(sys_user_password, USER_PASSWORD) FROM SYS_USERS WHERE USER_NAME = sys_user_name);
END;
$AUTHENTICATE_SYS_USER$ LANGUAGE plpgsql;
